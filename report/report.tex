% Header
\documentclass[a4paper]{article}%      autres choix : book, report
\usepackage[utf8]{inputenc}%           gestion des accents (source)
\usepackage[T1]{fontenc}%              gestion des accents (PDF)
\usepackage[francais]{babel}%          gestion du français
\usepackage{textcomp}%                 caractères additionnels
\usepackage{mathtools,amssymb,amsthm}% packages de l'AMS + mathtools
\usepackage{lmodern}%                  police de caractère
\usepackage[top=2cm,left=2cm,right=2cm,bottom=2cm]{geometry}%     gestion des marges
\usepackage{graphicx}%                 gestion des images
\usepackage{array}%                    gestion améliorée des tableaux
\usepackage{calc}%                     syntaxe naturelle pour les calculs
\usepackage{titlesec}%                 pour les sections
\usepackage{titletoc}%                 pour la table des matières
\usepackage{fancyhdr}%                 pour les en-têtes
\usepackage{titling}%                  pour le titre
\usepackage{enumitem}%                 pour les listes numérotées
\usepackage{hyperref}%                 gestion des hyperliens
\usepackage{bibentry}

\nobibliography*

\hypersetup{pdfstartview=XYZ}%         zoom par défaut

\setlength{\droptitle}{-5em}   % This is your set screw
\title{\vspace{1.5cm}Projet: Lustre Model Checker}
\author{Mickaël LAURENT}
\date{\vspace{-5ex}}

\pagenumbering{gobble}

\begin{document}

    \maketitle

    \section{Les choix techniques}
		
	\begin{itemize}
		\item \textbf{Alt-Ergo Zero}: Connaissant déjà Z3 (je l'avais beaucoup utilisé en stage de M1), j'ai décidé d'utiliser Alt-Ergo Zero pour ce projet,
		afin d'étendre mon expérience et de pouvoir comparer les deux SMT-solvers. Alt-Ergo Zero s'est trouvé être particulièrement adapté à ce projet:
		il est très minimal et reconnait exactement le fragment de logique dont j'ai eu besoin. Il est ainsi très adapté aux besoins et ne possède rien superflu).
		J'ai cependant eu quelques difficultés avec ce SMT-solver: voir section 2 et 3.\\
		\item \textbf{La gestion des flotants}: Alt-Ergo Zero ne gère pas les flotants, mais les fractions rationnelles (module Num de OCaml).
		J'ai donc dû convertir chaque valeur flotante du programme en fraction. Pour cela, j'ai opté pour le plus simple: j'ai fixé un dénominateur,
		et tous les flotants sont convertis en fraction avec ce dénominateur.
		En revanche, cela n'est pas très fidèle au comportement des flotants (qui au contraire sont le produit d'une mantisse et d'un exposant dynamique).\\
		\item \textbf{Noms de variable}: Pour garantir l'unicité des noms de variable (car une même variable du code peut donner lieu à plusieurs instances,
		par exemple si elle est locale à un noeud qui est appelé plisuers fois), j'ai décidé d'utiliser un identifiant unique de la forme "NAME\_\_ID\_\_NONCE"
		où NAME est le nom dela variable (utile pour déboguer), ID son identifiant dans l'AST, et NONCE un identifiant unique (incrémenté pour chaque nouvelle variable).
	\end{itemize}

	\section{Difficultés rencontrées et limitations}

	\begin{itemize}
		\item \textbf{Fonctions TE\_prim}: L'appel aux fonctions 'builtin' (de type TE\_Prim dans l'AST) n'est pas géré par mon model checker.
		Ces fonctions sont des fonctions de conversion int/float, et je n'ai pas trouvé de manière simple d'encoder cela dans Alt-Ergo Zero.
		J'ai pensé à encoder cela en introduisant une nouvelle variable du type résultant de la conversion (qui contiendra la valeur convertie)
		et d'ajouter des inégalités pour contraindre sa valeur (par exemple, pour convertir un flotant $x$ en entier, on introduit une nouvelle
		variable entière $n$ et on ajoute les inégalités $n <= x$ et $n+1 > x$). Cependant je ne l'ai pas implémenté pour le moment.\\
		\item \textbf{Utilisation d'Alt-Ergo Zero}: J'ai utilisé uniquement Alt-Ergo Zero (pas d'interface avec d'autres SMT-solver tels que Z3).
		Bien que minimal et adapté aux besoins, ce SMT-solver m'a tout de même posé quelques difficultés détaillées ci-après.\\
		\item \textbf{Distinction terme/formule}: Alt-Ergo Zero fait une distinction entre les termes (avec lesquels on peut representer les entiers
		et utiliser l'arithmétique) et les formules (booléenes, avec lesquels on peut utiliser les opérateurs booléens).
		Cette distinction n'existe pas dans le code, où le type booléen est un type comme un autre.
		Heureusement, il est facile de convertir un terme en formule (en le comparant avec le terme 't\_true') et inversement (grâce à la construction 'make\_ite').\\
		\item \textbf{Pas de substitution possible}: J'ai initialement pensé à construire la formule logique décrivant le système pour une variable $n$ générique,
		puis à substituer cette variable $n$ par ce dont j'ai besoin par la suite ($0$, $1$\dots pour l'initialisation, $n$, $n+1$ \ldots pour l'induction).
		Cependant, une fois une formule construite avec Alt-Ergo Zero, il n'est pas possible de substituer une variable (ou du moins je n'ai pas trouvé comment faire).
		Une solution aurait été d'introduire un AST intermédiaire pour les formules qui gère les substitions, puis de les convertir en formule de Alt-Ergo Zero par la suite.
		Cette solution aurait également permit de facilement intégrer plusieurs SMT-solvers (la seule partie à coder pour chaque SMT-solver serait la traduction de l'AST intermédiaire
		en formule spécifique au SMT-solver). Cependant, comme je n'avais pas dans l'optique d'utiliser plusieurs SMT-solvers, j'ai opté pour une solution plus simple:
		recalculer les formules à chaque fois, avec la valeur de $n$ désirée. Cela peut sembler peu efficace, mais cette opération est de toute manière très rapide
		(quasiment linéaire), et a donc un impact négligeable sur les performances (la résolution du système par le SMT-solver est beaucoup plus coûteuse).\\
		\item \textbf{Débogage nécessaire}: J'ai dû faire face à deux problèmes d'exécution d'Alt-Ergo Zero (exceptions non rattrapées en runtime). Les exceptions en question n'étant pas
		très évocatrices, j'ai dû déboguer le programme pour voir quelles en étaient les causes. Je détaille cela dans la prochaine section.
	\end{itemize}

	\section{Modifications d'Alt-Ergo Zero}

	\begin{itemize}
		\item \textbf{Conjonctions/disjonctions}: La première exception à laquelle j'ai été confronté était dû à mon utilisation des combinateurs
		'And' et 'Or'. En effet, bien que l'on puisse les utiliser avec un nombre quelconque de formules directement
		(ce ne sont pas des opérateurs binaires mais à priori des opérateurs d'arité quelconque),
		Alt-Ergo Zero échouera à l'exécution si l'on utilise le combinateur Or avec moins de deux formules
		(cela peut aussi arriver avec un opérateur And car il peut se transformer en Or après une négation).
		Cela est dû à un cas non géré dans la fonction 'mk\_cnf' (la transformation de formules en sform vers des clauses cnf).
		Ne connaissant pas bien le fonctionnement d'Alt-Ergo Zero, j'ai préféré modifier mon algorithme afin d'éviter ce cas pathologique,
		plûtot que de modifier le code d'Alt-Ergo Zero.\\
		\item \textbf{Sauvegarde/restauration des environments}: Le second problème que j'ai rencontré s'est trouvé être
		lié, après débogage, au système de restauration des environments d'Alt-Ergo Zero (utilisé pour le backtracking).
		En effet, la méthode 'cancel\_until' échouait parfois. Cela semble être dû au module Vec utilisé, qui, lors de la récupération d'un élément,
		retourne l'exception Not\_found au lieu de l'élément si ce dernier est égal à une certaine valeur par défaut ('dummy').
		Lorsque l'environment à restaurer est l'environment vide (je ne sais pas si cela est censé arriver, mais en tout cas ça arrive sur la plupart des formules que je génère),
		alors l'appel à la méthode 'get' du module Vec lance l'exception 'Not\_found' qui n'est pas rattrapée.
		J'ai modifié ce comportement dans le module Vec (afin de retourner l'élément même s'il est égal à l'élément par défaut,
		ce qui semble plus cohérent par rapport au comportement de certaines autres méthodes du module Vec).
		Je ne suis pas totalement sûr que ce changement soit sans effet néfaste à d'autres endroits du code, mais experimentalement cela m'a permis de régler
		le problème et donne des résultats exactes sur les quelques tests que j'ai fait.
		Vous pouvez tester mon programme sans ce correctif en recompilant une version non modifiée d'AEZ, mais dans ce cas le model checker devrait échouer sur la plupart des exemples.
	\end{itemize}
		
\end{document}